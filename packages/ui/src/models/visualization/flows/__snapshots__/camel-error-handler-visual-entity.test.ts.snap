// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CamelErrorHandlerVisualEntity getComponentSchema should return schema from store 1`] = `
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "additionalProperties": false,
  "anyOf": [
    {
      "oneOf": [
        {
          "properties": {
            "deadLetterChannel": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.DeadLetterChannelDefinition",
            },
          },
          "required": [
            "deadLetterChannel",
          ],
          "type": "object",
        },
        {
          "not": {
            "anyOf": [
              {
                "required": [
                  "deadLetterChannel",
                ],
              },
              {
                "required": [
                  "defaultErrorHandler",
                ],
              },
              {
                "required": [
                  "jtaTransactionErrorHandler",
                ],
              },
              {
                "required": [
                  "noErrorHandler",
                ],
              },
              {
                "required": [
                  "refErrorHandler",
                ],
              },
              {
                "required": [
                  "springTransactionErrorHandler",
                ],
              },
            ],
          },
        },
        {
          "properties": {
            "defaultErrorHandler": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition",
            },
          },
          "required": [
            "defaultErrorHandler",
          ],
          "type": "object",
        },
        {
          "properties": {
            "jtaTransactionErrorHandler": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition",
            },
          },
          "required": [
            "jtaTransactionErrorHandler",
          ],
          "type": "object",
        },
        {
          "properties": {
            "noErrorHandler": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.NoErrorHandlerDefinition",
            },
          },
          "required": [
            "noErrorHandler",
          ],
          "type": "object",
        },
        {
          "properties": {
            "refErrorHandler": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.RefErrorHandlerDefinition",
            },
          },
          "required": [
            "refErrorHandler",
          ],
          "type": "object",
        },
        {
          "properties": {
            "springTransactionErrorHandler": {
              "$ref": "#/definitions/org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition",
            },
          },
          "required": [
            "springTransactionErrorHandler",
          ],
          "type": "object",
        },
      ],
    },
  ],
  "definitions": {
    "org.apache.camel.model.RedeliveryPolicyDefinition": {
      "additionalProperties": false,
      "description": "To configure re-delivery for error handling",
      "properties": {
        "allowRedeliveryWhileStopping": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Controls whether to allow redelivery while stopping/shutting down a route that uses error handling.",
          "title": "Allow Redelivery While Stopping",
          "type": "boolean",
        },
        "asyncDelayedRedelivery": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Allow asynchronous delayed redelivery. The route, in particular the consumer's component, must support the Asynchronous Routing Engine (e.g. seda).",
          "title": "Async Delayed Redelivery",
          "type": "boolean",
        },
        "backOffMultiplier": {
          "$comment": "group:common",
          "default": "2.0",
          "description": "Sets the back off multiplier",
          "title": "Back Off Multiplier",
          "type": "number",
        },
        "collisionAvoidanceFactor": {
          "$comment": "group:advanced",
          "default": "0.15",
          "description": "Sets the collision avoidance factor",
          "title": "Collision Avoidance Factor",
          "type": "number",
        },
        "delayPattern": {
          "$comment": "group:advanced",
          "description": "Sets the delay pattern with delay intervals.",
          "title": "Delay Pattern",
          "type": "string",
        },
        "disableRedelivery": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Disables redelivery (same as setting maximum redeliveries to 0)",
          "title": "Disable Redelivery",
          "type": "boolean",
        },
        "exchangeFormatterRef": {
          "$comment": "group:advanced",
          "description": "Sets the reference of the instance of org.apache.camel.spi.ExchangeFormatter to generate the log message from exchange.",
          "title": "Exchange Formatter Ref",
          "type": "string",
        },
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "logContinued": {
          "$comment": "group:common",
          "default": false,
          "description": "Sets whether continued exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Continued",
          "type": "boolean",
        },
        "logExhausted": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Sets whether exhausted exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Exhausted",
          "type": "boolean",
        },
        "logExhaustedMessageBody": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Sets whether exhausted message body should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose. Requires logExhaustedMessageHistory to be enabled.",
          "title": "Log Exhausted Message Body",
          "type": "boolean",
        },
        "logExhaustedMessageHistory": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Sets whether exhausted exceptions should be logged including message history or not (supports property placeholders). Can be used to include or reduce verbose.",
          "title": "Log Exhausted Message History",
          "type": "boolean",
        },
        "logHandled": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Sets whether handled exceptions should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Handled",
          "type": "boolean",
        },
        "logNewException": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Sets whether new exceptions should be logged or not. Can be used to include or reduce verbose. A new exception is an exception that was thrown while handling a previous exception.",
          "title": "Log New Exception",
          "type": "boolean",
        },
        "logRetryAttempted": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Sets whether retry attempts should be logged or not. Can be used to include or reduce verbose.",
          "title": "Log Retry Attempted",
          "type": "boolean",
        },
        "logRetryStackTrace": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Sets whether stack traces should be logged when an retry attempt failed. Can be used to include or reduce verbose.",
          "title": "Log Retry Stack Trace",
          "type": "boolean",
        },
        "logStackTrace": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Sets whether stack traces should be logged. Can be used to include or reduce verbose.",
          "title": "Log Stack Trace",
          "type": "boolean",
        },
        "maximumRedeliveries": {
          "$comment": "group:common",
          "description": "Sets the maximum redeliveries x = redeliver at most x times 0 = no redeliveries -1 = redeliver forever",
          "title": "Maximum Redeliveries",
          "type": "number",
        },
        "maximumRedeliveryDelay": {
          "$comment": "group:common",
          "default": "60000",
          "description": "Sets the maximum delay between redelivery",
          "format": "duration",
          "title": "Maximum Redelivery Delay",
          "type": "string",
        },
        "redeliveryDelay": {
          "$comment": "group:common",
          "default": "1000",
          "description": "Sets the initial redelivery delay",
          "format": "duration",
          "title": "Redelivery Delay",
          "type": "string",
        },
        "retriesExhaustedLogLevel": {
          "$comment": "group:advanced",
          "default": "ERROR",
          "description": "Sets the logging level to use when retries have been exhausted",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Retries Exhausted Log Level",
          "type": "string",
        },
        "retryAttemptedLogInterval": {
          "$comment": "group:advanced",
          "default": "1",
          "description": "Sets the interval to use for logging retry attempts",
          "title": "Retry Attempted Log Interval",
          "type": "number",
        },
        "retryAttemptedLogLevel": {
          "$comment": "group:common",
          "default": "DEBUG",
          "description": "Sets the logging level to use for logging retry attempts",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Retry Attempted Log Level",
          "type": "string",
        },
        "useCollisionAvoidance": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Turn on collision avoidance.",
          "title": "Use Collision Avoidance",
          "type": "boolean",
        },
        "useExponentialBackOff": {
          "$comment": "group:advanced",
          "default": false,
          "description": "Turn on exponential back off",
          "title": "Use Exponential Back Off",
          "type": "boolean",
        },
      },
      "title": "Redelivery Policy",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.DeadLetterChannelDefinition": {
      "additionalProperties": false,
      "description": "Error handler with dead letter queue.",
      "properties": {
        "deadLetterHandleNewException": {
          "$comment": "group:advanced",
          "default": true,
          "description": "Whether the dead letter channel should handle (and ignore) any new exception that may been thrown during sending the message to the dead letter endpoint. The default value is true which means any such kind of exception is handled and ignored. Set this to false to let the exception be propagated back on the org.apache.camel.Exchange . This can be used in situations where you use transactions, and want to use Camel's dead letter channel to deal with exceptions during routing, but if the dead letter channel itself fails because of a new exception being thrown, then by setting this to false the new exceptions is propagated back and set on the org.apache.camel.Exchange , which allows the transaction to detect the exception, and rollback.",
          "title": "Dead Letter Handle New Exception",
          "type": "boolean",
        },
        "deadLetterUri": {
          "$comment": "group:common",
          "description": "The dead letter endpoint uri for the Dead Letter error handler.",
          "title": "Dead Letter Uri",
          "type": "string",
        },
        "executorServiceRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a thread pool to be used by the error handler",
          "format": "bean:java.util.concurrent.ScheduledExecutorService",
          "title": "Executor Service Ref",
          "type": "string",
        },
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "level": {
          "$comment": "group:advanced",
          "default": "ERROR",
          "description": "Logging level to use by error handler",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Level",
          "type": "string",
        },
        "logName": {
          "$comment": "group:advanced",
          "description": "Name of the logger to use by the error handler",
          "title": "Log Name",
          "type": "string",
        },
        "loggerRef": {
          "$comment": "group:advanced",
          "description": "References to a logger to use as logger for the error handler",
          "title": "Logger Ref",
          "type": "string",
        },
        "onExceptionOccurredRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Exception Occurred Ref",
          "type": "string",
        },
        "onPrepareFailureRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Prepare Failure Ref",
          "type": "string",
        },
        "onRedeliveryRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Redelivery Ref",
          "type": "string",
        },
        "redeliveryPolicy": {
          "$comment": "group:common",
          "$ref": "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition",
          "description": "Sets the redelivery settings",
          "title": "Redelivery Policy",
        },
        "redeliveryPolicyRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.",
          "format": "bean:org.apache.camel.processor.errorhandler.RedeliveryPolicy",
          "title": "Redelivery Policy Ref",
          "type": "string",
        },
        "retryWhileRef": {
          "$comment": "group:advanced",
          "description": "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.",
          "format": "bean:org.apache.camel.Processor",
          "title": "Retry While Ref",
          "type": "string",
        },
        "useOriginalBody": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Body",
          "type": "boolean",
        },
        "useOriginalMessage": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Message",
          "type": "boolean",
        },
      },
      "required": [
        "deadLetterUri",
      ],
      "title": "Dead Letter Channel",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.DefaultErrorHandlerDefinition": {
      "additionalProperties": false,
      "description": "The default error handler.",
      "properties": {
        "executorServiceRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a thread pool to be used by the error handler",
          "format": "bean:java.util.concurrent.ScheduledExecutorService",
          "title": "Executor Service Ref",
          "type": "string",
        },
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "level": {
          "$comment": "group:advanced",
          "default": "ERROR",
          "description": "Logging level to use by error handler",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Level",
          "type": "string",
        },
        "logName": {
          "$comment": "group:advanced",
          "description": "Name of the logger to use by the error handler",
          "title": "Log Name",
          "type": "string",
        },
        "loggerRef": {
          "$comment": "group:advanced",
          "description": "References to a logger to use as logger for the error handler",
          "title": "Logger Ref",
          "type": "string",
        },
        "onExceptionOccurredRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Exception Occurred Ref",
          "type": "string",
        },
        "onPrepareFailureRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Prepare Failure Ref",
          "type": "string",
        },
        "onRedeliveryRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Redelivery Ref",
          "type": "string",
        },
        "redeliveryPolicy": {
          "$comment": "group:common",
          "$ref": "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition",
          "description": "Sets the redelivery settings",
          "title": "Redelivery Policy",
        },
        "redeliveryPolicyRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.",
          "format": "bean:org.apache.camel.processor.errorhandler.RedeliveryPolicy",
          "title": "Redelivery Policy Ref",
          "type": "string",
        },
        "retryWhileRef": {
          "$comment": "group:advanced",
          "description": "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.",
          "format": "bean:org.apache.camel.Processor",
          "title": "Retry While Ref",
          "type": "string",
        },
        "useOriginalBody": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Body",
          "type": "boolean",
        },
        "useOriginalMessage": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Message",
          "type": "boolean",
        },
      },
      "title": "Default Error Handler",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.JtaTransactionErrorHandlerDefinition": {
      "additionalProperties": false,
      "description": "JTA based transactional error handler (requires camel-jta).",
      "properties": {
        "executorServiceRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a thread pool to be used by the error handler",
          "format": "bean:java.util.concurrent.ScheduledExecutorService",
          "title": "Executor Service Ref",
          "type": "string",
        },
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "level": {
          "$comment": "group:advanced",
          "default": "ERROR",
          "description": "Logging level to use by error handler",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Level",
          "type": "string",
        },
        "logName": {
          "$comment": "group:advanced",
          "description": "Name of the logger to use by the error handler",
          "title": "Log Name",
          "type": "string",
        },
        "loggerRef": {
          "$comment": "group:advanced",
          "description": "References to a logger to use as logger for the error handler",
          "title": "Logger Ref",
          "type": "string",
        },
        "onExceptionOccurredRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Exception Occurred Ref",
          "type": "string",
        },
        "onPrepareFailureRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Prepare Failure Ref",
          "type": "string",
        },
        "onRedeliveryRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Redelivery Ref",
          "type": "string",
        },
        "redeliveryPolicy": {
          "$comment": "group:common",
          "$ref": "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition",
          "description": "Sets the redelivery settings",
          "title": "Redelivery Policy",
        },
        "redeliveryPolicyRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.",
          "format": "bean:org.apache.camel.processor.errorhandler.RedeliveryPolicy",
          "title": "Redelivery Policy Ref",
          "type": "string",
        },
        "retryWhileRef": {
          "$comment": "group:advanced",
          "description": "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.",
          "format": "bean:org.apache.camel.Processor",
          "title": "Retry While Ref",
          "type": "string",
        },
        "rollbackLoggingLevel": {
          "$comment": "group:common",
          "default": "WARN",
          "description": "Sets the logging level to use for logging transactional rollback. This option is default WARN.",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Rollback Logging Level",
          "type": "string",
        },
        "transactedPolicyRef": {
          "$comment": "group:common",
          "description": "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover.",
          "format": "bean:org.apache.camel.spi.TransactedPolicy",
          "title": "Transacted Policy Ref",
          "type": "string",
        },
        "useOriginalBody": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Body",
          "type": "boolean",
        },
        "useOriginalMessage": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Message",
          "type": "boolean",
        },
      },
      "title": "Jta Transaction Error Handler",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.NoErrorHandlerDefinition": {
      "additionalProperties": false,
      "description": "To not use an error handler.",
      "properties": {
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
      },
      "title": "No Error Handler",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.RefErrorHandlerDefinition": {
      "additionalProperties": false,
      "description": "References to an existing or custom error handler.",
      "properties": {
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "ref": {
          "$comment": "group:common",
          "description": "References to an existing or custom error handler.",
          "format": "bean:org.apache.camel.ErrorHandlerFactory",
          "title": "Ref",
          "type": "string",
        },
      },
      "required": [
        "ref",
      ],
      "title": "Ref Error Handler",
      "type": "object",
    },
    "org.apache.camel.model.errorhandler.SpringTransactionErrorHandlerDefinition": {
      "additionalProperties": false,
      "description": "Spring based transactional error handler (requires camel-spring).",
      "properties": {
        "executorServiceRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a thread pool to be used by the error handler",
          "format": "bean:java.util.concurrent.ScheduledExecutorService",
          "title": "Executor Service Ref",
          "type": "string",
        },
        "id": {
          "$comment": "group:common",
          "description": "The id of this node",
          "title": "Id",
          "type": "string",
        },
        "level": {
          "$comment": "group:advanced",
          "default": "ERROR",
          "description": "Logging level to use by error handler",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Level",
          "type": "string",
        },
        "logName": {
          "$comment": "group:advanced",
          "description": "Name of the logger to use by the error handler",
          "title": "Log Name",
          "type": "string",
        },
        "loggerRef": {
          "$comment": "group:advanced",
          "description": "References to a logger to use as logger for the error handler",
          "title": "Logger Ref",
          "type": "string",
        },
        "onExceptionOccurredRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed just after an exception occurred. Can be used to perform custom logging about the occurred exception at the exact time it happened. Important: Any exception thrown from this processor will be ignored.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Exception Occurred Ref",
          "type": "string",
        },
        "onPrepareFailureRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor to prepare the org.apache.camel.Exchange before handled by the failure processor / dead letter channel. This allows for example to enrich the message before sending to a dead letter queue.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Prepare Failure Ref",
          "type": "string",
        },
        "onRedeliveryRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a processor that should be processed before a redelivery attempt. Can be used to change the org.apache.camel.Exchange before its being redelivered.",
          "format": "bean:org.apache.camel.Processor",
          "title": "On Redelivery Ref",
          "type": "string",
        },
        "redeliveryPolicy": {
          "$comment": "group:common",
          "$ref": "#/definitions/org.apache.camel.model.RedeliveryPolicyDefinition",
          "description": "Sets the redelivery settings",
          "title": "Redelivery Policy",
        },
        "redeliveryPolicyRef": {
          "$comment": "group:advanced",
          "description": "Sets a reference to a RedeliveryPolicy to be used for redelivery settings.",
          "format": "bean:org.apache.camel.processor.errorhandler.RedeliveryPolicy",
          "title": "Redelivery Policy Ref",
          "type": "string",
        },
        "retryWhileRef": {
          "$comment": "group:advanced",
          "description": "Sets a retry while predicate. Will continue retrying until the predicate evaluates to false.",
          "format": "bean:org.apache.camel.Processor",
          "title": "Retry While Ref",
          "type": "string",
        },
        "rollbackLoggingLevel": {
          "$comment": "group:common",
          "default": "WARN",
          "description": "Sets the logging level to use for logging transactional rollback. This option is default WARN.",
          "enum": [
            "TRACE",
            "DEBUG",
            "INFO",
            "WARN",
            "ERROR",
            "OFF",
          ],
          "title": "Rollback Logging Level",
          "type": "string",
        },
        "transactedPolicyRef": {
          "$comment": "group:common",
          "description": "The transacted policy to use that is configured for either Spring or JTA based transactions. If no policy has been configured then Camel will attempt to auto-discover.",
          "format": "bean:org.apache.camel.spi.TransactedPolicy",
          "title": "Transacted Policy Ref",
          "type": "string",
        },
        "useOriginalBody": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message body (original body only) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Body",
          "type": "boolean",
        },
        "useOriginalMessage": {
          "$comment": "group:common",
          "default": false,
          "description": "Will use the original input org.apache.camel.Message (original body and headers) when an org.apache.camel.Exchange is moved to the dead letter queue. Notice: this only applies when all redeliveries attempt have failed and the org.apache.camel.Exchange is doomed for failure. Instead of using the current inprogress org.apache.camel.Exchange IN message we use the original IN message instead. This allows you to store the original input in the dead letter queue instead of the inprogress snapshot of the IN message. For instance if you route transform the IN body during routing and then failed. With the original exchange store in the dead letter queue it might be easier to manually re submit the org.apache.camel.Exchange again as the IN message is the same as when Camel received it. So you should be able to send the org.apache.camel.Exchange to the same input. The difference between useOriginalMessage and useOriginalBody is that the former includes both the original body and headers, where as the latter only includes the original body. You can use the latter to enrich the message with custom headers and include the original message body. The former wont let you do this, as its using the original message body and headers as they are. You cannot enable both useOriginalMessage and useOriginalBody. The original input message is defensively copied, and the copied message body is converted to org.apache.camel.StreamCache if possible (stream caching is enabled, can be disabled globally or on the original route), to ensure the body can be read when the original message is being used later. If the body is converted to org.apache.camel.StreamCache then the message body on the current org.apache.camel.Exchange is replaced with the org.apache.camel.StreamCache body. If the body is not converted to org.apache.camel.StreamCache then the body will not be able to re-read when accessed later. Important: The original input means the input message that are bounded by the current org.apache.camel.spi.UnitOfWork . An unit of work typically spans one route, or multiple routes if they are connected using internal endpoints such as direct or seda. When messages is passed via external endpoints such as JMS or HTTP then the consumer will create a new unit of work, with the message it received as input as the original input. Also some EIP patterns such as splitter, multicast, will create a new unit of work boundary for the messages in their sub-route (eg the splitted message); however these EIPs have an option named shareUnitOfWork which allows to combine with the parent unit of work in regard to error handling and therefore use the parent original message. By default this feature is off.",
          "title": "Use Original Message",
          "type": "boolean",
        },
      },
      "title": "Spring Transaction Error Handler",
      "type": "object",
    },
  },
  "properties": {
    "deadLetterChannel": {},
    "defaultErrorHandler": {},
    "id": {
      "$comment": "group:common",
      "description": "The id of this node",
      "title": "Id",
      "type": "string",
    },
    "jtaTransactionErrorHandler": {},
    "noErrorHandler": {},
    "refErrorHandler": {},
    "springTransactionErrorHandler": {},
  },
  "type": "object",
}
`;
