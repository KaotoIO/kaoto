// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema for \`route\` entity 1`] = `
{
  "definition": {
    "from": {
      "parameters": {
        "timerName": "tutorial",
      },
      "uri": "timer",
    },
    "id": "route-1234",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "definitions": {
      "org.apache.camel.model.ErrorHandlerDefinition": {
        "$comment": "errorhandler",
        "additionalProperties": false,
        "description": "Camel error handling.",
        "properties": {
          "id": {
            "description": "The id of this node",
            "title": "Id",
            "type": "string",
          },
        },
        "title": "Error Handler",
        "type": "object",
      },
      "org.apache.camel.model.FromDefinition": {
        "additionalProperties": false,
        "properties": {
          "description": {
            "type": "string",
          },
          "id": {
            "type": "string",
          },
          "parameters": {
            "type": "object",
          },
          "steps": {
            "items": {
              "$ref": "#/definitions/org.apache.camel.model.ProcessorDefinition",
            },
            "type": "array",
          },
          "uri": {
            "type": "string",
          },
          "variableReceive": {
            "type": "string",
          },
        },
        "required": [
          "steps",
          "uri",
        ],
        "type": "object",
      },
      "org.apache.camel.model.InputTypeDefinition": {
        "additionalProperties": false,
        "description": "Set the expected data type of the input message. If the actual message type is different at runtime, camel look for a required Transformer and apply if exists. If validate attribute is true then camel applies Validator as well. Type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name' is a fully qualified class name. For example {code java:java.lang.String} , {code json:ABCOrder} . It's also possible to specify only scheme part, so that it works like a wildcard. If only 'xml' is specified, all the XML message matches. It's handy to add only one transformer/validator for all the transformation from/to XML.",
        "properties": {
          "description": {
            "description": "Sets the description of this node",
            "title": "Description",
            "type": "string",
          },
          "id": {
            "description": "Sets the id of this node",
            "title": "Id",
            "type": "string",
          },
          "urn": {
            "description": "The input type URN.",
            "title": "Urn",
            "type": "string",
          },
          "validate": {
            "description": "Whether if validation is required for this input type.",
            "title": "Validate",
            "type": "boolean",
          },
        },
        "required": [
          "urn",
        ],
        "title": "Input Type",
        "type": "object",
      },
      "org.apache.camel.model.OutputTypeDefinition": {
        "additionalProperties": false,
        "description": "Set the expected data type of the output message. If the actual message type is different at runtime, camel look for a required Transformer and apply if exists. If validate attribute is true then camel applies Validator as well. Type name consists of two parts, 'scheme' and 'name' connected with ':'. For Java type 'name' is a fully qualified class name. For example {code java:java.lang.String} , {code json:ABCOrder} . It's also possible to specify only scheme part, so that it works like a wildcard. If only 'xml' is specified, all the XML message matches. It's handy to add only one transformer/validator for all the XML-Java transformation.",
        "properties": {
          "description": {
            "description": "Sets the description of this node",
            "title": "Description",
            "type": "string",
          },
          "id": {
            "description": "Sets the id of this node",
            "title": "Id",
            "type": "string",
          },
          "urn": {
            "description": "Set output type URN.",
            "title": "Urn",
            "type": "string",
          },
          "validate": {
            "description": "Whether if validation is required for this output type.",
            "title": "Validate",
            "type": "boolean",
          },
        },
        "required": [
          "urn",
        ],
        "title": "Output Type",
        "type": "object",
      },
    },
    "properties": {
      "autoStartup": {
        "default": true,
        "description": "Whether to auto start this route",
        "title": "Auto Startup",
        "type": "boolean",
      },
      "description": {
        "description": "Sets the description of this node",
        "title": "Description",
        "type": "string",
      },
      "errorHandler": {
        "$ref": "#/definitions/org.apache.camel.model.ErrorHandlerDefinition",
        "description": "Sets the error handler to use for this route",
        "title": "Error Handler",
      },
      "errorHandlerRef": {
        "description": "Sets the bean ref name of the error handler builder to use on this route",
        "title": "Error Handler",
        "type": "string",
      },
      "from": {
        "$ref": "#/definitions/org.apache.camel.model.FromDefinition",
        "description": "From",
        "title": "From",
      },
      "group": {
        "description": "The group that this route belongs to; could be the name of the RouteBuilder class or be explicitly configured in the XML. May be null.",
        "title": "Group",
        "type": "string",
      },
      "id": {
        "description": "Sets the id of this node",
        "title": "Id",
        "type": "string",
      },
      "inputType": {
        "$ref": "#/definitions/org.apache.camel.model.InputTypeDefinition",
      },
      "logMask": {
        "default": false,
        "description": "Whether security mask for Logging is enabled on this route.",
        "title": "Log Mask",
        "type": "boolean",
      },
      "messageHistory": {
        "description": "Whether message history is enabled on this route.",
        "title": "Message History",
        "type": "boolean",
      },
      "nodePrefixId": {
        "description": "Sets a prefix to use for all node ids (not route id).",
        "title": "Node Prefix Id",
        "type": "string",
      },
      "outputType": {
        "$ref": "#/definitions/org.apache.camel.model.OutputTypeDefinition",
      },
      "precondition": {
        "description": "The predicate of the precondition in simple language to evaluate in order to determine if this route should be included or not.",
        "title": "Precondition",
        "type": "string",
      },
      "routeConfigurationId": {
        "description": "The route configuration id or pattern this route should use for configuration. Multiple id/pattern can be separated by comma.",
        "title": "Route Configuration Id",
        "type": "string",
      },
      "routePolicy": {
        "description": "Reference to custom org.apache.camel.spi.RoutePolicy to use by the route. Multiple policies can be configured by separating values using comma.",
        "title": "Route Policy",
        "type": "string",
      },
      "shutdownRoute": {
        "default": "Default",
        "description": "To control how to shutdown the route.",
        "enum": [
          "Default",
          "Defer",
        ],
        "title": "Shutdown Route",
        "type": "string",
      },
      "shutdownRunningTask": {
        "default": "CompleteCurrentTaskOnly",
        "description": "To control how to shut down the route.",
        "enum": [
          "CompleteCurrentTaskOnly",
          "CompleteAllTasks",
        ],
        "title": "Shutdown Running Task",
        "type": "string",
      },
      "startupOrder": {
        "description": "To configure the ordering of the routes being started",
        "title": "Startup Order",
        "type": "number",
      },
      "streamCache": {
        "description": "Whether stream caching is enabled on this route.",
        "title": "Stream Cache",
        "type": "boolean",
      },
      "trace": {
        "description": "Whether tracing is enabled on this route.",
        "title": "Trace",
        "type": "boolean",
      },
    },
    "required": [
      "from",
    ],
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema for kamelets 1`] = `
{
  "definition": {
    "id": "to-3044",
    "parameters": {},
    "uri": "kamelet:kafka-not-secured-sink",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a static endpoint",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "bootstrapServers": {
            "description": "Comma separated list of Kafka Broker URLs",
            "title": "Bootstrap Servers",
            "type": "string",
          },
          "topic": {
            "description": "Comma separated list of Kafka topic names",
            "title": "Topic Names",
            "type": "string",
          },
        },
        "required": [
          "topic",
          "bootstrapServers",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [],
    "title": "To",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema for processors combined that holds a component 1`] = `
{
  "definition": {
    "id": "to-3044",
    "parameters": {
      "groupActiveOnly": true,
      "level": "ERROR",
      "logMask": true,
    },
    "uri": "log",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a static endpoint",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "exchangeFormatter": {
            "$comment": "class:org.apache.camel.spi.ExchangeFormatter",
            "deprecated": false,
            "description": "To use a custom exchange formatter",
            "group": "advanced",
            "title": "Exchange Formatter",
            "type": "string",
          },
          "groupActiveOnly": {
            "default": "true",
            "deprecated": false,
            "description": "If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.",
            "group": "producer",
            "title": "Group Active Only",
            "type": "boolean",
          },
          "groupDelay": {
            "deprecated": false,
            "description": "Set the initial delay for stats (in millis)",
            "group": "producer",
            "title": "Group Delay",
            "type": "integer",
          },
          "groupInterval": {
            "deprecated": false,
            "description": "If specified will group message stats by this time interval (in millis)",
            "group": "producer",
            "title": "Group Interval",
            "type": "integer",
          },
          "groupSize": {
            "deprecated": false,
            "description": "An integer that specifies a group size for throughput logging.",
            "group": "producer",
            "title": "Group Size",
            "type": "integer",
          },
          "lazyStartProducer": {
            "default": false,
            "deprecated": false,
            "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
            "group": "producer (advanced)",
            "title": "Lazy Start Producer",
            "type": "boolean",
          },
          "level": {
            "default": "INFO",
            "deprecated": false,
            "description": "Logging level to use. The default value is INFO.",
            "enum": [
              "TRACE",
              "DEBUG",
              "INFO",
              "WARN",
              "ERROR",
              "OFF",
            ],
            "group": "producer",
            "title": "Level",
            "type": "string",
          },
          "logMask": {
            "deprecated": false,
            "description": "If true, mask sensitive information like password or passphrase in the log.",
            "group": "producer",
            "title": "Log Mask",
            "type": "boolean",
          },
          "loggerName": {
            "deprecated": false,
            "description": "Name of the logging category to use",
            "group": "producer",
            "title": "Logger Name",
            "type": "string",
          },
          "marker": {
            "deprecated": false,
            "description": "An optional Marker name to use.",
            "group": "producer",
            "title": "Marker",
            "type": "string",
          },
          "maxChars": {
            "default": 10000,
            "deprecated": false,
            "description": "Limits the number of characters logged per line.",
            "group": "formatting",
            "title": "Max Chars",
            "type": "integer",
          },
          "multiline": {
            "default": false,
            "deprecated": false,
            "description": "If enabled then each information is outputted on a newline.",
            "group": "formatting",
            "title": "Multiline",
            "type": "boolean",
          },
          "plain": {
            "default": false,
            "deprecated": false,
            "description": "If enabled only the body will be printed out",
            "group": "producer",
            "title": "Plain",
            "type": "boolean",
          },
          "showAll": {
            "default": false,
            "deprecated": false,
            "description": "Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)",
            "group": "formatting",
            "title": "Show All",
            "type": "boolean",
          },
          "showAllProperties": {
            "default": false,
            "deprecated": false,
            "description": "Show all of the exchange properties (both internal and custom).",
            "group": "formatting",
            "title": "Show All Properties",
            "type": "boolean",
          },
          "showBody": {
            "default": true,
            "deprecated": false,
            "description": "Show the message body.",
            "group": "formatting",
            "title": "Show Body",
            "type": "boolean",
          },
          "showBodyType": {
            "default": true,
            "deprecated": false,
            "description": "Show the body Java type.",
            "group": "formatting",
            "title": "Show Body Type",
            "type": "boolean",
          },
          "showCachedStreams": {
            "default": true,
            "deprecated": false,
            "description": "Whether Camel should show cached stream bodies or not (org.apache.camel.StreamCache).",
            "group": "formatting",
            "title": "Show Cached Streams",
            "type": "boolean",
          },
          "showCaughtException": {
            "default": false,
            "deprecated": false,
            "description": "If the exchange has a caught exception, show the exception message (no stack trace). A caught exception is stored as a property on the exchange (using the key org.apache.camel.Exchange#EXCEPTION_CAUGHT) and for instance a doCatch can catch exceptions.",
            "group": "formatting",
            "title": "Show Caught Exception",
            "type": "boolean",
          },
          "showException": {
            "default": false,
            "deprecated": false,
            "description": "If the exchange has an exception, show the exception message (no stacktrace)",
            "group": "formatting",
            "title": "Show Exception",
            "type": "boolean",
          },
          "showExchangeId": {
            "default": false,
            "deprecated": false,
            "description": "Show the unique exchange ID.",
            "group": "formatting",
            "title": "Show Exchange Id",
            "type": "boolean",
          },
          "showExchangePattern": {
            "default": false,
            "deprecated": false,
            "description": "Shows the Message Exchange Pattern (or MEP for short).",
            "group": "formatting",
            "title": "Show Exchange Pattern",
            "type": "boolean",
          },
          "showFiles": {
            "default": false,
            "deprecated": false,
            "description": "If enabled Camel will output files",
            "group": "formatting",
            "title": "Show Files",
            "type": "boolean",
          },
          "showFuture": {
            "default": false,
            "deprecated": false,
            "description": "If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.",
            "group": "formatting",
            "title": "Show Future",
            "type": "boolean",
          },
          "showHeaders": {
            "default": false,
            "deprecated": false,
            "description": "Show the message headers.",
            "group": "formatting",
            "title": "Show Headers",
            "type": "boolean",
          },
          "showProperties": {
            "default": false,
            "deprecated": false,
            "description": "Show the exchange properties (only custom). Use showAllProperties to show both internal and custom properties.",
            "group": "formatting",
            "title": "Show Properties",
            "type": "boolean",
          },
          "showRouteGroup": {
            "default": false,
            "deprecated": false,
            "description": "Show route Group.",
            "group": "formatting",
            "title": "Show Route Group",
            "type": "boolean",
          },
          "showRouteId": {
            "default": false,
            "deprecated": false,
            "description": "Show route ID.",
            "group": "formatting",
            "title": "Show Route Id",
            "type": "boolean",
          },
          "showStackTrace": {
            "default": false,
            "deprecated": false,
            "description": "Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.",
            "group": "formatting",
            "title": "Show Stack Trace",
            "type": "boolean",
          },
          "showStreams": {
            "default": false,
            "deprecated": false,
            "description": "Whether Camel should show stream bodies or not (eg such as java.io.InputStream). Beware if you enable this option then you may not be able later to access the message body as the stream have already been read by this logger. To remedy this you will have to use Stream Caching.",
            "group": "formatting",
            "title": "Show Streams",
            "type": "boolean",
          },
          "showVariables": {
            "default": false,
            "deprecated": false,
            "description": "Show the variables.",
            "group": "formatting",
            "title": "Show Variables",
            "type": "boolean",
          },
          "skipBodyLineSeparator": {
            "default": true,
            "deprecated": false,
            "description": "Whether to skip line separators when logging the message body. This allows to log the message body in one line, setting this option to false will preserve any line separators from the body, which then will log the body as is.",
            "group": "formatting",
            "title": "Skip Body Line Separator",
            "type": "boolean",
          },
          "sourceLocationLoggerName": {
            "default": false,
            "deprecated": false,
            "description": "If enabled then the source location of where the log endpoint is used in Camel routes, would be used as logger name, instead of the given name. However, if the source location is disabled or not possible to resolve then the existing logger name will be used.",
            "group": "producer",
            "title": "Source Location Logger Name",
            "type": "boolean",
          },
          "style": {
            "default": "Default",
            "deprecated": false,
            "description": "Sets the outputs style to use.",
            "enum": [
              "Default",
              "Tab",
              "Fixed",
            ],
            "group": "formatting",
            "title": "Style",
            "type": "string",
          },
        },
        "required": [
          "loggerName",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [],
    "title": "To",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema for standalone processors 1`] = `
{
  "definition": {
    "message": "Hello World",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Used for printing custom messages to the logger.",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "logName": {
        "description": "Sets the name of the logger. The name is default the routeId or the source:line if source location is enabled. You can also specify the name using tokens: \${class} - the logger class name (org.apache.camel.processor.LogProcessor) \${contextId} - the camel context id \${routeId} - the route id \${groupId} - the route group id \${nodeId} - the node id \${nodePrefixId} - the node prefix id \${source} - the source:line (source location must be enabled) \${source.name} - the source filename (source location must be enabled) \${source.line} - the source line number (source location must be enabled) For example to use the route and node id you can specify the name as: \${routeId}/\${nodeId}",
        "group": "common",
        "title": "Log Name",
        "type": "string",
      },
      "logger": {
        "$comment": "class:org.slf4j.Logger",
        "description": "To refer to a custom logger instance to lookup from the registry.",
        "group": "advanced",
        "title": "Logger",
        "type": "string",
      },
      "loggingLevel": {
        "default": "INFO",
        "description": "Sets the logging level. The default value is INFO",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF",
        ],
        "group": "common",
        "title": "Logging Level",
        "type": "string",
      },
      "marker": {
        "description": "To use slf4j marker",
        "group": "advanced",
        "title": "Marker",
        "type": "string",
      },
      "message": {
        "description": "Sets the log message (uses simple language)",
        "group": "common",
        "title": "Message",
        "type": "string",
      },
    },
    "required": [
      "message",
    ],
    "title": "Logger",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema without any consumer parameters 1`] = `
{
  "definition": {
    "id": "to-3044",
    "parameters": {},
    "uri": "file",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a static endpoint",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "allowNullBody": {
            "default": false,
            "deprecated": false,
            "description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
            "group": "producer (advanced)",
            "title": "Allow Null Body",
            "type": "boolean",
          },
          "antExclude": {
            "deprecated": false,
            "description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
            "group": "filter",
            "title": "Ant Exclude",
            "type": "string",
          },
          "antFilterCaseSensitive": {
            "default": true,
            "deprecated": false,
            "description": "Sets case sensitive flag on ant filter.",
            "group": "filter",
            "title": "Ant Filter Case Sensitive",
            "type": "boolean",
          },
          "antInclude": {
            "deprecated": false,
            "description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
            "group": "filter",
            "title": "Ant Include",
            "type": "string",
          },
          "appendChars": {
            "deprecated": false,
            "description": "Used to append characters (text) after writing files. This can for example be used to add new lines or other separators when writing and appending new files or existing files. To specify new-line (slash-n or slash-r) or tab (slash-t) characters then escape with an extra slash, eg slash-slash-n.",
            "group": "producer",
            "title": "Append Chars",
            "type": "string",
          },
          "autoCreate": {
            "default": true,
            "deprecated": false,
            "description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
            "group": "advanced",
            "title": "Auto Create",
            "type": "boolean",
          },
          "autoCreateStepwise": {
            "default": false,
            "deprecated": false,
            "description": "When auto-creating directories should each subdirectory be created one at a time. This may be needed due to security issues on some file-shares.",
            "group": "advanced",
            "title": "Auto Create Stepwise",
            "type": "boolean",
          },
          "backoffErrorThreshold": {
            "deprecated": false,
            "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
            "group": "scheduler",
            "title": "Backoff Error Threshold",
            "type": "integer",
          },
          "backoffIdleThreshold": {
            "deprecated": false,
            "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
            "group": "scheduler",
            "title": "Backoff Idle Threshold",
            "type": "integer",
          },
          "backoffMultiplier": {
            "deprecated": false,
            "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
            "group": "scheduler",
            "title": "Backoff Multiplier",
            "type": "integer",
          },
          "bufferSize": {
            "default": 131072,
            "deprecated": false,
            "description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
            "group": "advanced",
            "title": "Buffer Size",
            "type": "integer",
          },
          "charset": {
            "deprecated": false,
            "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
            "group": "common",
            "title": "Charset",
            "type": "string",
          },
          "checksumFileAlgorithm": {
            "deprecated": false,
            "description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
            "enum": [
              "MD2",
              "MD5",
              "SHA_1",
              "SHA_224",
              "SHA_256",
              "SHA_384",
              "SHA_512",
              "SHA_512_224",
              "SHA_512_256",
              "SHA3_224",
              "SHA3_256",
              "SHA3_384",
              "SHA3_512",
            ],
            "group": "producer",
            "title": "Checksum File Algorithm",
            "type": "string",
          },
          "chmod": {
            "deprecated": false,
            "description": "Specify the file permissions that are sent by the producer, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it.",
            "group": "producer (advanced)",
            "title": "Chmod",
            "type": "string",
          },
          "chmodDirectory": {
            "deprecated": false,
            "description": "Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it.",
            "group": "producer (advanced)",
            "title": "Chmod Directory",
            "type": "string",
          },
          "copyAndDeleteOnRenameFail": {
            "default": true,
            "deprecated": false,
            "description": "Whether to fall back and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.",
            "group": "advanced",
            "title": "Copy And Delete On Rename Fail",
            "type": "boolean",
          },
          "delay": {
            "default": 500,
            "deprecated": false,
            "description": "Milliseconds before the next poll.",
            "group": "scheduler",
            "title": "Delay",
            "type": "integer",
          },
          "directoryName": {
            "deprecated": false,
            "description": "The starting directory",
            "group": "common",
            "title": "Directory Name",
            "type": "string",
          },
          "doneFileName": {
            "deprecated": false,
            "description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only \${file.name} and \${file.name.next} is supported as dynamic placeholders.",
            "group": "common",
            "title": "Done File Name",
            "type": "string",
          },
          "eagerDeleteTargetFile": {
            "default": true,
            "deprecated": false,
            "description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
            "group": "producer (advanced)",
            "title": "Eager Delete Target File",
            "type": "boolean",
          },
          "eagerMaxMessagesPerPoll": {
            "default": true,
            "deprecated": false,
            "description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
            "group": "filter",
            "title": "Eager Max Messages Per Poll",
            "type": "boolean",
          },
          "exclude": {
            "deprecated": false,
            "description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
            "group": "filter",
            "title": "Exclude",
            "type": "string",
          },
          "excludeExt": {
            "deprecated": false,
            "description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
            "group": "filter",
            "title": "Exclude Ext",
            "type": "string",
          },
          "exclusiveReadLockStrategy": {
            "$comment": "class:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<java.io.File>",
            "deprecated": false,
            "description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
            "group": "lock",
            "title": "Exclusive Read Lock Strategy",
            "type": "string",
          },
          "fileExist": {
            "default": "Override",
            "deprecated": false,
            "description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
            "enum": [
              "Override",
              "Append",
              "Fail",
              "Ignore",
              "Move",
              "TryRename",
            ],
            "group": "producer",
            "title": "File Exist",
            "type": "string",
          },
          "fileName": {
            "deprecated": false,
            "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-\${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
            "group": "common",
            "title": "File Name",
            "type": "string",
          },
          "filter": {
            "$comment": "class:org.apache.camel.component.file.GenericFileFilter<java.io.File>",
            "deprecated": false,
            "description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
            "group": "filter",
            "title": "Filter",
            "type": "string",
          },
          "filterDirectory": {
            "deprecated": false,
            "description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as \${date:now:yyyMMdd}",
            "group": "filter",
            "title": "Filter Directory",
            "type": "string",
          },
          "filterFile": {
            "deprecated": false,
            "description": "Filters the file based on Simple language. For example to filter on file size, you can use \${file:size} 5000",
            "group": "filter",
            "title": "Filter File",
            "type": "string",
          },
          "flatten": {
            "default": false,
            "deprecated": false,
            "description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
            "group": "producer",
            "title": "Flatten",
            "type": "boolean",
          },
          "forceWrites": {
            "default": true,
            "deprecated": false,
            "description": "Whether to force syncing, writes to the file system. You can turn this off if you do not want this level of guarantee, for example, if writing to logs / audit logs etc.; this would yield better performance.",
            "group": "producer (advanced)",
            "title": "Force Writes",
            "type": "boolean",
          },
          "greedy": {
            "default": false,
            "deprecated": false,
            "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
            "group": "scheduler",
            "title": "Greedy",
            "type": "boolean",
          },
          "idempotent": {
            "default": "false",
            "deprecated": false,
            "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
            "group": "filter",
            "title": "Idempotent",
            "type": "boolean",
          },
          "idempotentEager": {
            "default": "false",
            "deprecated": false,
            "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
            "group": "filter",
            "title": "Idempotent Eager",
            "type": "boolean",
          },
          "idempotentKey": {
            "deprecated": false,
            "description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=\${file:name}-\${file:size}",
            "group": "filter",
            "title": "Idempotent Key",
            "type": "string",
          },
          "idempotentRepository": {
            "$comment": "class:org.apache.camel.spi.IdempotentRepository",
            "deprecated": false,
            "description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
            "group": "filter",
            "title": "Idempotent Repository",
            "type": "string",
          },
          "include": {
            "deprecated": false,
            "description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
            "group": "filter",
            "title": "Include",
            "type": "string",
          },
          "includeExt": {
            "deprecated": false,
            "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
            "group": "filter",
            "title": "Include Ext",
            "type": "string",
          },
          "initialDelay": {
            "default": 1000,
            "deprecated": false,
            "description": "Milliseconds before the first poll starts.",
            "group": "scheduler",
            "title": "Initial Delay",
            "type": "integer",
          },
          "jailStartingDirectory": {
            "default": true,
            "deprecated": false,
            "description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
            "group": "producer",
            "title": "Jail Starting Directory",
            "type": "boolean",
          },
          "keepLastModified": {
            "default": false,
            "deprecated": false,
            "description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
            "group": "producer (advanced)",
            "title": "Keep Last Modified",
            "type": "boolean",
          },
          "lazyStartProducer": {
            "default": false,
            "deprecated": false,
            "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
            "group": "producer (advanced)",
            "title": "Lazy Start Producer",
            "type": "boolean",
          },
          "maxDepth": {
            "default": 2147483647,
            "deprecated": false,
            "description": "The maximum depth to traverse when recursively processing a directory.",
            "group": "filter",
            "title": "Max Depth",
            "type": "integer",
          },
          "maxMessagesPerPoll": {
            "deprecated": false,
            "description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
            "group": "filter",
            "title": "Max Messages Per Poll",
            "type": "integer",
          },
          "minDepth": {
            "deprecated": false,
            "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
            "group": "filter",
            "title": "Min Depth",
            "type": "integer",
          },
          "move": {
            "deprecated": false,
            "description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
            "group": "filter",
            "title": "Move",
            "type": "string",
          },
          "moveExisting": {
            "deprecated": false,
            "description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
            "group": "producer",
            "title": "Move Existing",
            "type": "string",
          },
          "moveExistingFileStrategy": {
            "$comment": "class:org.apache.camel.component.file.strategy.FileMoveExistingStrategy",
            "deprecated": false,
            "description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
            "group": "producer (advanced)",
            "title": "Move Existing File Strategy",
            "type": "string",
          },
          "readLock": {
            "default": "none",
            "deprecated": false,
            "description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
            "enum": [
              "none",
              "markerFile",
              "fileLock",
              "rename",
              "changed",
              "idempotent",
              "idempotent-changed",
              "idempotent-rename",
            ],
            "group": "lock",
            "title": "Read Lock",
            "type": "string",
          },
          "readLockCheckInterval": {
            "default": 1000,
            "deprecated": false,
            "description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
            "group": "lock",
            "title": "Read Lock Check Interval",
            "type": "integer",
          },
          "readLockDeleteOrphanLockFiles": {
            "default": true,
            "deprecated": false,
            "description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
            "group": "lock",
            "title": "Read Lock Delete Orphan Lock Files",
            "type": "boolean",
          },
          "readLockIdempotentReleaseAsync": {
            "default": false,
            "deprecated": false,
            "description": "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Async",
            "type": "boolean",
          },
          "readLockIdempotentReleaseAsyncPoolSize": {
            "deprecated": false,
            "description": "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Async Pool Size",
            "type": "integer",
          },
          "readLockIdempotentReleaseDelay": {
            "deprecated": false,
            "description": "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Delay",
            "type": "integer",
          },
          "readLockIdempotentReleaseExecutorService": {
            "$comment": "class:java.util.concurrent.ScheduledExecutorService",
            "deprecated": false,
            "description": "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Executor Service",
            "type": "string",
          },
          "readLockLoggingLevel": {
            "default": "DEBUG",
            "deprecated": false,
            "description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
            "enum": [
              "TRACE",
              "DEBUG",
              "INFO",
              "WARN",
              "ERROR",
              "OFF",
            ],
            "group": "lock",
            "title": "Read Lock Logging Level",
            "type": "string",
          },
          "readLockMarkerFile": {
            "default": true,
            "deprecated": false,
            "description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
            "group": "lock",
            "title": "Read Lock Marker File",
            "type": "boolean",
          },
          "readLockMinAge": {
            "default": 0,
            "deprecated": false,
            "description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
            "group": "lock",
            "title": "Read Lock Min Age",
            "type": "integer",
          },
          "readLockMinLength": {
            "default": 1,
            "deprecated": false,
            "description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
            "group": "lock",
            "title": "Read Lock Min Length",
            "type": "integer",
          },
          "readLockRemoveOnCommit": {
            "default": false,
            "deprecated": false,
            "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Remove On Commit",
            "type": "boolean",
          },
          "readLockRemoveOnRollback": {
            "default": true,
            "deprecated": false,
            "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
            "group": "lock",
            "title": "Read Lock Remove On Rollback",
            "type": "boolean",
          },
          "readLockTimeout": {
            "default": 10000,
            "deprecated": false,
            "description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
            "group": "lock",
            "title": "Read Lock Timeout",
            "type": "integer",
          },
          "renameUsingCopy": {
            "default": false,
            "deprecated": false,
            "description": "Perform rename operations using a copy and delete strategy. This is primarily used in environments where the regular rename operation is unreliable (e.g., across different file systems or networks). This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy, but only after additional delays.",
            "group": "advanced",
            "title": "Rename Using Copy",
            "type": "boolean",
          },
          "repeatCount": {
            "default": 0,
            "deprecated": false,
            "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
            "group": "scheduler",
            "title": "Repeat Count",
            "type": "integer",
          },
          "runLoggingLevel": {
            "default": "TRACE",
            "deprecated": false,
            "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
            "enum": [
              "TRACE",
              "DEBUG",
              "INFO",
              "WARN",
              "ERROR",
              "OFF",
            ],
            "group": "scheduler",
            "title": "Run Logging Level",
            "type": "string",
          },
          "scheduledExecutorService": {
            "$comment": "class:java.util.concurrent.ScheduledExecutorService",
            "deprecated": false,
            "description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
            "group": "scheduler",
            "title": "Scheduled Executor Service",
            "type": "string",
          },
          "scheduler": {
            "$comment": "class:java.lang.Object",
            "default": "none",
            "deprecated": false,
            "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
            "group": "scheduler",
            "title": "Scheduler",
            "type": "string",
          },
          "schedulerProperties": {
            "deprecated": false,
            "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
            "group": "scheduler",
            "title": "Scheduler Properties",
            "type": "object",
          },
          "shuffle": {
            "default": false,
            "deprecated": false,
            "description": "To shuffle the list of files (sort in random order)",
            "group": "sort",
            "title": "Shuffle",
            "type": "boolean",
          },
          "sortBy": {
            "deprecated": false,
            "description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
            "group": "sort",
            "title": "Sort By",
            "type": "string",
          },
          "sorter": {
            "$comment": "class:java.util.Comparator<org.apache.camel.component.file.GenericFile<java.io.File>>",
            "deprecated": false,
            "description": "Pluggable sorter as a java.util.Comparator class.",
            "group": "sort",
            "title": "Sorter",
            "type": "string",
          },
          "startScheduler": {
            "default": true,
            "deprecated": false,
            "description": "Whether the scheduler should be auto started.",
            "group": "scheduler",
            "title": "Start Scheduler",
            "type": "boolean",
          },
          "synchronous": {
            "default": false,
            "deprecated": false,
            "description": "Sets whether synchronous processing should be strictly used",
            "group": "advanced",
            "title": "Synchronous",
            "type": "boolean",
          },
          "tempFileName": {
            "deprecated": false,
            "description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
            "group": "producer",
            "title": "Temp File Name",
            "type": "string",
          },
          "tempPrefix": {
            "deprecated": false,
            "description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
            "group": "producer",
            "title": "Temp Prefix",
            "type": "string",
          },
          "timeUnit": {
            "default": "MILLISECONDS",
            "deprecated": false,
            "description": "Time unit for initialDelay and delay options.",
            "enum": [
              "NANOSECONDS",
              "MICROSECONDS",
              "MILLISECONDS",
              "SECONDS",
              "MINUTES",
              "HOURS",
              "DAYS",
            ],
            "group": "scheduler",
            "title": "Time Unit",
            "type": "string",
          },
          "useFixedDelay": {
            "default": true,
            "deprecated": false,
            "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
            "group": "scheduler",
            "title": "Use Fixed Delay",
            "type": "boolean",
          },
        },
        "required": [
          "directoryName",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [],
    "title": "To",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should build the appropriate schema without any producer parameters 1`] = `
{
  "definition": {
    "parameters": {},
    "uri": "file",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "properties": {
      "description": {
        "deprecated": false,
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "id": {
        "deprecated": false,
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "antExclude": {
            "deprecated": false,
            "description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
            "group": "filter",
            "title": "Ant Exclude",
            "type": "string",
          },
          "antFilterCaseSensitive": {
            "default": true,
            "deprecated": false,
            "description": "Sets case sensitive flag on ant filter.",
            "group": "filter",
            "title": "Ant Filter Case Sensitive",
            "type": "boolean",
          },
          "antInclude": {
            "deprecated": false,
            "description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
            "group": "filter",
            "title": "Ant Include",
            "type": "string",
          },
          "autoCreate": {
            "default": true,
            "deprecated": false,
            "description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
            "group": "advanced",
            "title": "Auto Create",
            "type": "boolean",
          },
          "autoCreateStepwise": {
            "default": false,
            "deprecated": false,
            "description": "When auto-creating directories should each subdirectory be created one at a time. This may be needed due to security issues on some file-shares.",
            "group": "advanced",
            "title": "Auto Create Stepwise",
            "type": "boolean",
          },
          "backoffErrorThreshold": {
            "deprecated": false,
            "description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
            "group": "scheduler",
            "title": "Backoff Error Threshold",
            "type": "integer",
          },
          "backoffIdleThreshold": {
            "deprecated": false,
            "description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
            "group": "scheduler",
            "title": "Backoff Idle Threshold",
            "type": "integer",
          },
          "backoffMultiplier": {
            "deprecated": false,
            "description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
            "group": "scheduler",
            "title": "Backoff Multiplier",
            "type": "integer",
          },
          "bridgeErrorHandler": {
            "default": false,
            "deprecated": false,
            "description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
            "group": "consumer (advanced)",
            "title": "Bridge Error Handler",
            "type": "boolean",
          },
          "bufferSize": {
            "default": 131072,
            "deprecated": false,
            "description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
            "group": "advanced",
            "title": "Buffer Size",
            "type": "integer",
          },
          "charset": {
            "deprecated": false,
            "description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
            "group": "common",
            "title": "Charset",
            "type": "string",
          },
          "copyAndDeleteOnRenameFail": {
            "default": true,
            "deprecated": false,
            "description": "Whether to fall back and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.",
            "group": "advanced",
            "title": "Copy And Delete On Rename Fail",
            "type": "boolean",
          },
          "delay": {
            "default": 500,
            "deprecated": false,
            "description": "Milliseconds before the next poll.",
            "group": "scheduler",
            "title": "Delay",
            "type": "integer",
          },
          "delete": {
            "default": false,
            "deprecated": false,
            "description": "If true, the file will be deleted after it is processed successfully.",
            "group": "consumer",
            "title": "Delete",
            "type": "boolean",
          },
          "directoryMustExist": {
            "default": false,
            "deprecated": false,
            "description": "Similar to the startingDirectoryMustExist option, but this applies during polling (after starting the consumer).",
            "group": "consumer (advanced)",
            "title": "Directory Must Exist",
            "type": "boolean",
          },
          "directoryName": {
            "deprecated": false,
            "description": "The starting directory",
            "group": "common",
            "title": "Directory Name",
            "type": "string",
          },
          "doneFileName": {
            "deprecated": false,
            "description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only \${file.name} and \${file.name.next} is supported as dynamic placeholders.",
            "group": "common",
            "title": "Done File Name",
            "type": "string",
          },
          "eagerMaxMessagesPerPoll": {
            "default": true,
            "deprecated": false,
            "description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
            "group": "filter",
            "title": "Eager Max Messages Per Poll",
            "type": "boolean",
          },
          "exceptionHandler": {
            "$comment": "class:org.apache.camel.spi.ExceptionHandler",
            "deprecated": false,
            "description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
            "group": "consumer (advanced)",
            "title": "Exception Handler",
            "type": "string",
          },
          "exchangePattern": {
            "deprecated": false,
            "description": "Sets the exchange pattern when the consumer creates an exchange.",
            "enum": [
              "InOnly",
              "InOut",
            ],
            "group": "consumer (advanced)",
            "title": "Exchange Pattern",
            "type": "string",
          },
          "exclude": {
            "deprecated": false,
            "description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
            "group": "filter",
            "title": "Exclude",
            "type": "string",
          },
          "excludeExt": {
            "deprecated": false,
            "description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
            "group": "filter",
            "title": "Exclude Ext",
            "type": "string",
          },
          "exclusiveReadLockStrategy": {
            "$comment": "class:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<java.io.File>",
            "deprecated": false,
            "description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
            "group": "lock",
            "title": "Exclusive Read Lock Strategy",
            "type": "string",
          },
          "extendedAttributes": {
            "deprecated": false,
            "description": "To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime, it supports basic wildcard like posix:, basic:lastAccessTime",
            "group": "consumer (advanced)",
            "title": "Extended Attributes",
            "type": "string",
          },
          "fileName": {
            "deprecated": false,
            "description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-\${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
            "group": "common",
            "title": "File Name",
            "type": "string",
          },
          "filter": {
            "$comment": "class:org.apache.camel.component.file.GenericFileFilter<java.io.File>",
            "deprecated": false,
            "description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
            "group": "filter",
            "title": "Filter",
            "type": "string",
          },
          "filterDirectory": {
            "deprecated": false,
            "description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as \${date:now:yyyMMdd}",
            "group": "filter",
            "title": "Filter Directory",
            "type": "string",
          },
          "filterFile": {
            "deprecated": false,
            "description": "Filters the file based on Simple language. For example to filter on file size, you can use \${file:size} 5000",
            "group": "filter",
            "title": "Filter File",
            "type": "string",
          },
          "greedy": {
            "default": false,
            "deprecated": false,
            "description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
            "group": "scheduler",
            "title": "Greedy",
            "type": "boolean",
          },
          "idempotent": {
            "default": "false",
            "deprecated": false,
            "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
            "group": "filter",
            "title": "Idempotent",
            "type": "boolean",
          },
          "idempotentEager": {
            "default": "false",
            "deprecated": false,
            "description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
            "group": "filter",
            "title": "Idempotent Eager",
            "type": "boolean",
          },
          "idempotentKey": {
            "deprecated": false,
            "description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=\${file:name}-\${file:size}",
            "group": "filter",
            "title": "Idempotent Key",
            "type": "string",
          },
          "idempotentRepository": {
            "$comment": "class:org.apache.camel.spi.IdempotentRepository",
            "deprecated": false,
            "description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
            "group": "filter",
            "title": "Idempotent Repository",
            "type": "string",
          },
          "inProgressRepository": {
            "$comment": "class:org.apache.camel.spi.IdempotentRepository",
            "deprecated": false,
            "description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
            "group": "consumer (advanced)",
            "title": "In Progress Repository",
            "type": "string",
          },
          "include": {
            "deprecated": false,
            "description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
            "group": "filter",
            "title": "Include",
            "type": "string",
          },
          "includeExt": {
            "deprecated": false,
            "description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
            "group": "filter",
            "title": "Include Ext",
            "type": "string",
          },
          "includeHiddenDirs": {
            "default": false,
            "deprecated": false,
            "description": "Whether to accept hidden directories. Directories which names starts with dot are regarded as a hidden directory, and by default are not included. Set this option to true to include hidden directories in the file consumer.",
            "group": "consumer (advanced)",
            "title": "Include Hidden Dirs",
            "type": "boolean",
          },
          "includeHiddenFiles": {
            "default": false,
            "deprecated": false,
            "description": "Whether to accept hidden files. Files which names starts with dot is regarded as a hidden file, and by default not included. Set this option to true to include hidden files in the file consumer.",
            "group": "consumer (advanced)",
            "title": "Include Hidden Files",
            "type": "boolean",
          },
          "initialDelay": {
            "default": 1000,
            "deprecated": false,
            "description": "Milliseconds before the first poll starts.",
            "group": "scheduler",
            "title": "Initial Delay",
            "type": "integer",
          },
          "localWorkDirectory": {
            "deprecated": false,
            "description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
            "group": "consumer (advanced)",
            "title": "Local Work Directory",
            "type": "string",
          },
          "maxDepth": {
            "default": 2147483647,
            "deprecated": false,
            "description": "The maximum depth to traverse when recursively processing a directory.",
            "group": "filter",
            "title": "Max Depth",
            "type": "integer",
          },
          "maxMessagesPerPoll": {
            "deprecated": false,
            "description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
            "group": "filter",
            "title": "Max Messages Per Poll",
            "type": "integer",
          },
          "minDepth": {
            "deprecated": false,
            "description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
            "group": "filter",
            "title": "Min Depth",
            "type": "integer",
          },
          "move": {
            "deprecated": false,
            "description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
            "group": "filter",
            "title": "Move",
            "type": "string",
          },
          "moveFailed": {
            "deprecated": false,
            "description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
            "group": "consumer",
            "title": "Move Failed",
            "type": "string",
          },
          "noop": {
            "default": false,
            "deprecated": false,
            "description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
            "group": "consumer",
            "title": "Noop",
            "type": "boolean",
          },
          "onCompletionExceptionHandler": {
            "$comment": "class:org.apache.camel.spi.ExceptionHandler",
            "deprecated": false,
            "description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
            "group": "consumer (advanced)",
            "title": "On Completion Exception Handler",
            "type": "string",
          },
          "pollStrategy": {
            "$comment": "class:org.apache.camel.spi.PollingConsumerPollStrategy",
            "deprecated": false,
            "description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
            "group": "consumer (advanced)",
            "title": "Poll Strategy",
            "type": "string",
          },
          "preMove": {
            "deprecated": false,
            "description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
            "group": "consumer",
            "title": "Pre Move",
            "type": "string",
          },
          "preSort": {
            "default": false,
            "deprecated": false,
            "description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
            "group": "consumer",
            "title": "Pre Sort",
            "type": "boolean",
          },
          "probeContentType": {
            "default": false,
            "deprecated": false,
            "description": "Whether to enable probing of the content type. If enable then the consumer uses Files#probeContentType(java.nio.file.Path) to determine the content-type of the file, and store that as a header with key Exchange#FILE_CONTENT_TYPE on the Message.",
            "group": "consumer (advanced)",
            "title": "Probe Content Type",
            "type": "boolean",
          },
          "processStrategy": {
            "$comment": "class:org.apache.camel.component.file.GenericFileProcessStrategy<java.io.File>",
            "deprecated": false,
            "description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
            "group": "consumer (advanced)",
            "title": "Process Strategy",
            "type": "string",
          },
          "readLock": {
            "default": "none",
            "deprecated": false,
            "description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
            "enum": [
              "none",
              "markerFile",
              "fileLock",
              "rename",
              "changed",
              "idempotent",
              "idempotent-changed",
              "idempotent-rename",
            ],
            "group": "lock",
            "title": "Read Lock",
            "type": "string",
          },
          "readLockCheckInterval": {
            "default": 1000,
            "deprecated": false,
            "description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
            "group": "lock",
            "title": "Read Lock Check Interval",
            "type": "integer",
          },
          "readLockDeleteOrphanLockFiles": {
            "default": true,
            "deprecated": false,
            "description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
            "group": "lock",
            "title": "Read Lock Delete Orphan Lock Files",
            "type": "boolean",
          },
          "readLockIdempotentReleaseAsync": {
            "default": false,
            "deprecated": false,
            "description": "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Async",
            "type": "boolean",
          },
          "readLockIdempotentReleaseAsyncPoolSize": {
            "deprecated": false,
            "description": "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Async Pool Size",
            "type": "integer",
          },
          "readLockIdempotentReleaseDelay": {
            "deprecated": false,
            "description": "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Delay",
            "type": "integer",
          },
          "readLockIdempotentReleaseExecutorService": {
            "$comment": "class:java.util.concurrent.ScheduledExecutorService",
            "deprecated": false,
            "description": "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Idempotent Release Executor Service",
            "type": "string",
          },
          "readLockLoggingLevel": {
            "default": "DEBUG",
            "deprecated": false,
            "description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
            "enum": [
              "TRACE",
              "DEBUG",
              "INFO",
              "WARN",
              "ERROR",
              "OFF",
            ],
            "group": "lock",
            "title": "Read Lock Logging Level",
            "type": "string",
          },
          "readLockMarkerFile": {
            "default": true,
            "deprecated": false,
            "description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
            "group": "lock",
            "title": "Read Lock Marker File",
            "type": "boolean",
          },
          "readLockMinAge": {
            "default": 0,
            "deprecated": false,
            "description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
            "group": "lock",
            "title": "Read Lock Min Age",
            "type": "integer",
          },
          "readLockMinLength": {
            "default": 1,
            "deprecated": false,
            "description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
            "group": "lock",
            "title": "Read Lock Min Length",
            "type": "integer",
          },
          "readLockRemoveOnCommit": {
            "default": false,
            "deprecated": false,
            "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
            "group": "lock",
            "title": "Read Lock Remove On Commit",
            "type": "boolean",
          },
          "readLockRemoveOnRollback": {
            "default": true,
            "deprecated": false,
            "description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
            "group": "lock",
            "title": "Read Lock Remove On Rollback",
            "type": "boolean",
          },
          "readLockTimeout": {
            "default": 10000,
            "deprecated": false,
            "description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
            "group": "lock",
            "title": "Read Lock Timeout",
            "type": "integer",
          },
          "recursive": {
            "default": false,
            "deprecated": false,
            "description": "If a directory, will look for files in all the sub-directories as well.",
            "group": "consumer",
            "title": "Recursive",
            "type": "boolean",
          },
          "renameUsingCopy": {
            "default": false,
            "deprecated": false,
            "description": "Perform rename operations using a copy and delete strategy. This is primarily used in environments where the regular rename operation is unreliable (e.g., across different file systems or networks). This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy, but only after additional delays.",
            "group": "advanced",
            "title": "Rename Using Copy",
            "type": "boolean",
          },
          "repeatCount": {
            "default": 0,
            "deprecated": false,
            "description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
            "group": "scheduler",
            "title": "Repeat Count",
            "type": "integer",
          },
          "runLoggingLevel": {
            "default": "TRACE",
            "deprecated": false,
            "description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
            "enum": [
              "TRACE",
              "DEBUG",
              "INFO",
              "WARN",
              "ERROR",
              "OFF",
            ],
            "group": "scheduler",
            "title": "Run Logging Level",
            "type": "string",
          },
          "scheduledExecutorService": {
            "$comment": "class:java.util.concurrent.ScheduledExecutorService",
            "deprecated": false,
            "description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
            "group": "scheduler",
            "title": "Scheduled Executor Service",
            "type": "string",
          },
          "scheduler": {
            "$comment": "class:java.lang.Object",
            "default": "none",
            "deprecated": false,
            "description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
            "group": "scheduler",
            "title": "Scheduler",
            "type": "string",
          },
          "schedulerProperties": {
            "deprecated": false,
            "description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
            "group": "scheduler",
            "title": "Scheduler Properties",
            "type": "object",
          },
          "sendEmptyMessageWhenIdle": {
            "default": false,
            "deprecated": false,
            "description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
            "group": "consumer",
            "title": "Send Empty Message When Idle",
            "type": "boolean",
          },
          "shuffle": {
            "default": false,
            "deprecated": false,
            "description": "To shuffle the list of files (sort in random order)",
            "group": "sort",
            "title": "Shuffle",
            "type": "boolean",
          },
          "sortBy": {
            "deprecated": false,
            "description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
            "group": "sort",
            "title": "Sort By",
            "type": "string",
          },
          "sorter": {
            "$comment": "class:java.util.Comparator<org.apache.camel.component.file.GenericFile<java.io.File>>",
            "deprecated": false,
            "description": "Pluggable sorter as a java.util.Comparator class.",
            "group": "sort",
            "title": "Sorter",
            "type": "string",
          },
          "startScheduler": {
            "default": true,
            "deprecated": false,
            "description": "Whether the scheduler should be auto started.",
            "group": "scheduler",
            "title": "Start Scheduler",
            "type": "boolean",
          },
          "startingDirectoryMustExist": {
            "default": false,
            "deprecated": false,
            "description": "Whether the starting directory must exist. Mind that the autoCreate option is default enabled, which means the starting directory is normally auto created if it doesn't exist. You can disable autoCreate and enable this to ensure the starting directory must exist. Will throw an exception if the directory doesn't exist.",
            "group": "consumer (advanced)",
            "title": "Starting Directory Must Exist",
            "type": "boolean",
          },
          "startingDirectoryMustHaveAccess": {
            "default": false,
            "deprecated": false,
            "description": "Whether the starting directory has access permissions. Mind that the startingDirectoryMustExist parameter must be set to true to verify that the directory exists. Will throw an exception if the directory doesn't have read and write permissions.",
            "group": "consumer (advanced)",
            "title": "Starting Directory Must Have Access",
            "type": "boolean",
          },
          "synchronous": {
            "default": false,
            "deprecated": false,
            "description": "Sets whether synchronous processing should be strictly used",
            "group": "advanced",
            "title": "Synchronous",
            "type": "boolean",
          },
          "timeUnit": {
            "default": "MILLISECONDS",
            "deprecated": false,
            "description": "Time unit for initialDelay and delay options.",
            "enum": [
              "NANOSECONDS",
              "MICROSECONDS",
              "MILLISECONDS",
              "SECONDS",
              "MINUTES",
              "HOURS",
              "DAYS",
            ],
            "group": "scheduler",
            "title": "Time Unit",
            "type": "string",
          },
          "useFixedDelay": {
            "default": true,
            "deprecated": false,
            "description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
            "group": "scheduler",
            "title": "Use Fixed Delay",
            "type": "boolean",
          },
        },
        "required": [
          "directoryName",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "uri": {
        "deprecated": false,
        "description": "Sets the URI of the endpoint to use",
        "group": "common",
        "title": "Uri",
        "type": "string",
      },
      "variableReceive": {
        "deprecated": false,
        "description": "To use a variable to store a copy of the received message body (only body, not headers). This is handy for easy access to the received message body via variables.",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
    },
    "required": [
      "uri",
    ],
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should not build a schema for an unknown component 1`] = `
{
  "definition": {
    "id": "to-3044",
    "parameters": {
      "level": "ERROR",
    },
    "uri": "non-existing-component",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a static endpoint",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [],
    "title": "To",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should transform a string-based \`Log\` processor 1`] = `
{
  "definition": {
    "message": "\${body}",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Used for printing custom messages to the logger.",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "logName": {
        "description": "Sets the name of the logger. The name is default the routeId or the source:line if source location is enabled. You can also specify the name using tokens: \${class} - the logger class name (org.apache.camel.processor.LogProcessor) \${contextId} - the camel context id \${routeId} - the route id \${groupId} - the route group id \${nodeId} - the node id \${nodePrefixId} - the node prefix id \${source} - the source:line (source location must be enabled) \${source.name} - the source filename (source location must be enabled) \${source.line} - the source line number (source location must be enabled) For example to use the route and node id you can specify the name as: \${routeId}/\${nodeId}",
        "group": "common",
        "title": "Log Name",
        "type": "string",
      },
      "logger": {
        "$comment": "class:org.slf4j.Logger",
        "description": "To refer to a custom logger instance to lookup from the registry.",
        "group": "advanced",
        "title": "Logger",
        "type": "string",
      },
      "loggingLevel": {
        "default": "INFO",
        "description": "Sets the logging level. The default value is INFO",
        "enum": [
          "TRACE",
          "DEBUG",
          "INFO",
          "WARN",
          "ERROR",
          "OFF",
        ],
        "group": "common",
        "title": "Logging Level",
        "type": "string",
      },
      "marker": {
        "description": "To use slf4j marker",
        "group": "advanced",
        "title": "Marker",
        "type": "string",
      },
      "message": {
        "description": "Sets the log message (uses simple language)",
        "group": "common",
        "title": "Message",
        "type": "string",
      },
    },
    "required": [
      "message",
    ],
    "title": "Logger",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should transform a string-based \`To\` processor 1`] = `
{
  "definition": {
    "parameters": {
      "beanName": "myBean",
      "method": "hello",
      "parameters": {},
    },
    "uri": "bean",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a static endpoint",
    "properties": {
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "beanName": {
            "deprecated": false,
            "description": "Sets the name of the bean to invoke",
            "group": "common",
            "title": "Bean Name",
            "type": "string",
          },
          "lazyStartProducer": {
            "default": false,
            "deprecated": false,
            "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
            "group": "producer (advanced)",
            "title": "Lazy Start Producer",
            "type": "boolean",
          },
          "method": {
            "deprecated": false,
            "description": "Sets the name of the method to invoke on the bean",
            "group": "common",
            "title": "Method",
            "type": "string",
          },
          "parameters": {
            "deprecated": false,
            "description": "Used for configuring additional properties on the bean",
            "group": "advanced",
            "title": "Parameters",
            "type": "object",
          },
          "scope": {
            "default": "Singleton",
            "deprecated": false,
            "description": "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
            "enum": [
              "Singleton",
              "Request",
              "Prototype",
            ],
            "group": "common",
            "title": "Scope",
            "type": "string",
          },
        },
        "required": [
          "beanName",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [],
    "title": "To",
    "type": "object",
  },
}
`;

exports[`CamelComponentSchemaService getVisualComponentSchema should transform a string-based \`ToD\` processor 1`] = `
{
  "definition": {
    "parameters": {
      "beanName": "myBean",
      "method": "hello",
      "parameters": {},
    },
    "uri": "bean",
  },
  "schema": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "additionalProperties": false,
    "description": "Sends the message to a dynamic endpoint",
    "properties": {
      "allowOptimisedComponents": {
        "description": "Whether to allow components to optimise toD if they are org.apache.camel.spi.SendDynamicAware .",
        "group": "advanced",
        "title": "Allow Optimised Components",
        "type": "boolean",
      },
      "autoStartComponents": {
        "description": "Whether to auto startup components when toD is starting up.",
        "group": "advanced",
        "title": "Auto Start Components",
        "type": "boolean",
      },
      "cacheSize": {
        "description": "Sets the maximum size used by the org.apache.camel.spi.ProducerCache which is used to cache and reuse producers when using this recipient list, when uris are reused. Beware that when using dynamic endpoints then it affects how well the cache can be utilized. If each dynamic endpoint is unique then its best to turn off caching by setting this to -1, which allows Camel to not cache both the producers and endpoints; they are regarded as prototype scoped and will be stopped and discarded after use. This reduces memory usage as otherwise producers/endpoints are stored in memory in the caches. However if there are a high degree of dynamic endpoints that have been used before, then it can benefit to use the cache to reuse both producers and endpoints and therefore the cache size can be set accordingly or rely on the default size (1000). If there is a mix of unique and used before dynamic endpoints, then setting a reasonable cache size can help reduce memory usage to avoid storing too many non frequent used producers.",
        "group": "advanced",
        "title": "Cache Size",
        "type": "number",
      },
      "description": {
        "description": "Sets the description of this node",
        "group": "common",
        "title": "Description",
        "type": "string",
      },
      "disabled": {
        "description": "Whether to disable this EIP from the route during build time. Once an EIP has been disabled then it cannot be enabled later at runtime.",
        "group": "advanced",
        "title": "Disabled",
        "type": "boolean",
      },
      "id": {
        "description": "Sets the id of this node",
        "group": "common",
        "title": "Id",
        "type": "string",
      },
      "ignoreInvalidEndpoint": {
        "description": "Whether to ignore invalid endpoint URIs and skip sending the message.",
        "group": "advanced",
        "title": "Ignore Invalid Endpoint",
        "type": "boolean",
      },
      "parameters": {
        "description": "Endpoint properties description",
        "properties": {
          "beanName": {
            "deprecated": false,
            "description": "Sets the name of the bean to invoke",
            "group": "common",
            "title": "Bean Name",
            "type": "string",
          },
          "lazyStartProducer": {
            "default": false,
            "deprecated": false,
            "description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
            "group": "producer (advanced)",
            "title": "Lazy Start Producer",
            "type": "boolean",
          },
          "method": {
            "deprecated": false,
            "description": "Sets the name of the method to invoke on the bean",
            "group": "common",
            "title": "Method",
            "type": "string",
          },
          "parameters": {
            "deprecated": false,
            "description": "Used for configuring additional properties on the bean",
            "group": "advanced",
            "title": "Parameters",
            "type": "object",
          },
          "scope": {
            "default": "Singleton",
            "deprecated": false,
            "description": "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
            "enum": [
              "Singleton",
              "Request",
              "Prototype",
            ],
            "group": "common",
            "title": "Scope",
            "type": "string",
          },
        },
        "required": [
          "beanName",
        ],
        "title": "Endpoint Properties",
        "type": "object",
      },
      "pattern": {
        "description": "Sets the optional ExchangePattern used to invoke this endpoint",
        "enum": [
          "InOnly",
          "InOut",
        ],
        "group": "advanced",
        "title": "Pattern",
        "type": "string",
      },
      "uri": {
        "description": "The uri of the endpoint to send to. The uri can be dynamic computed using the org.apache.camel.language.simple.SimpleLanguage expression.",
        "group": "common",
        "title": "Uri",
        "type": "string",
      },
      "variableReceive": {
        "description": "To use a variable as the source for the message body to send. This makes it handy to use variables for user data and to easily control what data to use for sending and receiving. Important: When using send variable then the message body is taken from this variable instead of the current Message , however the headers from the Message will still be used as well. In other words, the variable is used instead of the message body, but everything else is as usual.",
        "group": "common",
        "title": "Variable Receive",
        "type": "string",
      },
      "variableSend": {
        "description": "To use a variable to store the received message body (only body, not headers). This is handy for easy access to the received message body via variables. Important: When using receive variable then the received body is stored only in this variable and not on the current org.apache.camel.Message .",
        "group": "common",
        "title": "Variable Send",
        "type": "string",
      },
    },
    "required": [
      "uri",
    ],
    "title": "To D",
    "type": "object",
  },
}
`;
